# 单例模式

## 什么是单例模式？

单例模式是前端开发中常用的设计模式，单例模式本身也比较简单，掌握度也是比较高的。

设计原理：确保一个类只有一个实例，并且提供一个访问它的全局访问点。

## 实现

UML图如下
![alt text](/img/JS/singletonUML.png)

从上图中可以看出，将其构造方法私有化，这样外界就无法实例化它了，并且暴露出了一个访问它唯一实例的方法。
::: tip 优点
1、控制实例化数量，节省资源。

2、提供全局唯一的访问点，适合共享全局资源（如数据库连接、配置管理）。
:::

示例：

```js
const test = {
   name: 'testName',
   age: '18',
};

export default test;
```

Js也可以使用`class`这么写

```js
class test{
   constructor(){
      this.name='testName',
      this.age= '18'
   }
};

export default test;
```

使用

```js
import test from './test';

console.log(test.name，test.age);
```

上述例子定义test并且export default暴露唯一的实例test，符合确保一个类只有一个实例，并且提供一个访问它的全局访问点原则。

## 接下来说说缺点

### 1、全局状态导致的隐式依赖

单例模式创建了全局唯一的实例，这意味着任何代码都可以访问它并修改其状态。这样可能导致隐式依赖，尤其是在大型项目中：

- 问题：任何地方都可以修改单例对象的状态，这可能使得代码难以理解和维护，因为你无法直接追踪哪些部分在修改它。

- 后果：这种隐式依赖会让代码变得难以维护，增加了理解和调试的难度。

例：
```js
const value = "a"
class test{
   constructor(){
      this.name='testName',
      this.age= '18'
   }
   setValue(){
      value = "b";
   }
   getValue(){
      console.log(value)
   }
};

export default test;
```

```js
const a = new test();
a.setValue();
const b = new test();
b.getValue();//此时输出的是   b
```
### 2、单例对象难以扩展

单例模式将实例化过程封装在内部，导致无法轻松扩展：

- 问题：当你需要扩展单例类的功能时，修改单例类的代码可能会影响到所有使用该类的地方。这会导致大规模的代码变动，尤其是在系统越来越大的时候。
- 后果：这种耦合性高的设计会限制你对类的灵活扩展和修改。
如果文件种有一个基础值，那引入的文件都会同时使用同一个值

## 需要注意的点
单例对象通常是全局的，且在整个程序生命周期内存在：

- 问题：如果单例对象的生命周期过长（例如从程序启动到结束），它会一直占用内存，并且它的状态可能会在应用程序生命周期中变得越来越复杂。
- 后果：如果不适当地清理或销毁单例实例，它可能会占用过多的系统资源，特别是在长时间运行的程序中。

::: tip 
单例模式有很多种实现方式，并且不同的实现方式有不同的适用场景，应该通过不同的业务需求灵活来编写代码。
:::

# 参考文献：

<CustomLink title='《设计模式在前端开发中的实践（十二）——单例模式》'  href='https://juejin.cn/post/7325800801040793637?searchId=20241116102055C39C443D65D2901A0E5B'/>
<CustomLink title='《想成为中高级前端，必须理解这10种javascript设计模式》'  href='https://juejin.cn/post/7433277439634096168'/>

