# 构建工具发展史

这里简单记录下构建工具的发展历史和实现了什么功能，解决了什么问题；

## 整理时间线

- 1. 2009 年，Kevin Dangoor 发起了 ServerJS 项目，后更名为 CommonJS，不是面向浏览器
- 3. 2011 年，AMD 规范诞生，面向浏览器
- 5. 2013 年，Grunt、Gulp第一版相继发布，同年，面向浏览器端模块的打包工具Browserify发布；
- 6. 2014 年，UMD发布，Babel 诞生（6TO5）,，webpack第一个稳定版本发布
- 7. 2015 年，ES6 Module 规范正式诞生，Rollup 项目诞生，基于 ES6 模块化，提供了  的功能；
- 11. 2019 年，snowpack将node_modules转为ESM的构建工具开始出现；
- 12. 2020 年，snowpack也开始内置使用esbuild；
- 13. 2021 年，Vite 诞生

## 早期简单脚本阶段

在前端开发的早期，`JavaScript` 主要用于简单的表单验证和少量的前端交互，代码量较少，通常将所有代码写在一个文件中，或者直接嵌入到 `HTML` 页面中。随着 `Ajax` 的流行，前端代码量迅速增加，开始出现将代码拆分成多个文件，通过 `<script>` 标签引入的方式，但这种方式存在全局变量污染、依赖关系混乱以及加载顺序难以控制等问题。

## 模块规范诞生阶段

- **CommonJS**：2009 年 `Node.js` 诞生，带来了 `CommonJS` 模块规范。该规范主要用于服务端，它定义了一套统一的模块化代码规范，使用require来导入模块，module.exports来导出模块。随着 Node.js 的普及，CommonJS 规范被广泛应用，但它在浏览器端存在一些问题，如模块加载是同步的，会导致 `浏览器阻塞`，且依赖 Node.js 的文件系统等功能，**无法直接在浏览器中运行**。
- **AMD**：2010 年诞生了 AMD（异步模块定义）规范，解决了 CommonJS 在浏览器端的问题，`RequireJS` 是基于 `AMD` 规范的模块加载工具。AMD 规范采用`异步加载模块`的方式，避免了同步加载导致的阻塞问题，适合在浏览器环境中使用。
- **CMD**：2011 年，由淘宝出品的 SeaJS 实现了 CMD（通用模块定义）规范，它解决的问题和 AMD 类似，但在模块加载和执行的策略上有所不同。例如，CMD 推崇依赖就近、懒执行，而 AMD 推崇依赖前置、预执行。不过随着社区的发展，SeaJS 逐渐被 `RequireJS` 兼容。
- **UMD**：UMD（统一模块定义）规范 `兼容` 了 CommonJS 和 AMD，为模块在多种环境下的运行提供了支持，使得模块可以同时在浏览器和服务器端运行。
- **ES6 Module**：2015 年，`ECMAScript` 正式发布了 ES6 Module 规范，它是官方提出的模块化规范，得到了现代浏览器的内置支持。在 HTML 中，通过设置`<script type="module">`标签，浏览器会按照 ES6 Module 规范来进行依赖加载和模块解析。

## 工具链创新阶段

- **Browserify**：基于 CommonJS 规范的模块打包工具，它可以将 Node.js 中的模块打包成浏览器能够识别的代码，使得 CommonJS 风格的模块能够在浏览器端运行。
- **Webpack**：2012 年发布，是一个兼容多种模块规范的重量级打包工具。它允许开发者将 JavaScript、CSS、图片等所有静态资源视为模块，并通过 loader 转换不同类型的文件为可被 Webpack 理解的模块，还引入了插件系统以扩展功能，如代码分割、Tree Shaking、Scope Hoisting 等，极大地提高了应用加载速度和资源利用率。
- **Babel**：能让用户提前用上 ES6 Module 语法的 JS 编译器，它可以将 ES6 及以上版本的代码转换为兼容旧版本浏览器的代码，解决了浏览器对新语法支持不兼容的问题。
- **Rollup**：2015 年登场，主要针对库和框架的打包需求，它充分利用 ES6 模块的特点，尤其擅长去除未引用的模块代码，生成更纯净、体积更小的 bundle，促进了社区对原生模块标准的采纳和推广。
- **Vite**：2020 年出现，基于浏览器原生 ES Module 支持，在开发阶段实现了 no - bundle 构建，摒弃了传统打包工具在开发环境下的冗余编译过程，显著提升了开发效率，优化了开发体验。
