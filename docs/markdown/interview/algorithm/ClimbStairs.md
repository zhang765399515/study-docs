# 爬楼梯

  背景是今天刷到了leetcode的每日算法题，今日题为爬楼梯。

## 题目描述

假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

需要我们写一个`fun`。

示例 1：

```
输入：n = 2
输出：2
```

解释：有两种方法可以爬到楼顶。

```
1. 1 阶 + 1 阶
2. 2 阶
```

示例 2：

```
输入：n = 3
输出：3
```

解释：有三种方法可以爬到楼顶。

```
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

## 解题

题目提到，每次可以爬1或2个台阶，爬到n阶有多少种不同的方法。比如`n = 2`的时候输出2，`n = 3`的时候输出3。看起来像是一个经典的动态规划问题，或者可能有数学规律？

首先，我应该先理解问题。假设我要到第n阶，那么最后一步可能是从`n - 1`阶爬1阶上来，或者从`n - 2`阶爬2阶上来。那这样的话，到达n阶的方法数应该等于到达n-1阶和n-2阶方法数的总和。这听起来像斐波那契数列的规律。

比如，当n=1的时候，只有一种方法；n=2的时候两种；n=3的时候是1+2=3种，和例子给出的结果一致。那这样的话，可能这个问题的解法和`斐波那契数列`是一样的。

## 实现

那接下来要考虑的是如何实现这个算法。如果用递归的话，可能会重复计算很多次，比如计算`f(n)=f(n-1)+f(n-2)`，这样时间复杂度会很`高`，是指数级的，对于较大的n来说效率太低。所以应该用动态规划来优化，或者直接迭代计算。

动态规划的常规做法是自底向上，保存每一步的结果。比如，初始化一个数组dp，其中dp[i]表示到达第i阶的方法数。那么dp[0]=1？或者需要重新考虑初始条件。比如，当n=0的时候可能认为是1种方法（不爬），然后n=1的时候是1种，n=2是2种。所以初始条件可能是dp[0] = 1，dp[1] = 1。然后从i=2开始，到n，每次`dp[i] = dp[i-1] + dp[i-2]`。这样计算到n，就能得到结果。

比如，当n=2的时候，dp[2] = dp[1] + dp[0] = 1+1=2，符合示例。n=3的时候，dp[3] = dp[2]+dp[1] =2+1=3，也符合。所以这样的初始条件是对的。

那代码已经成功实现了

```js
var climbStairs = function(n) {
    // 处理边界情况：n=0 或 n=1 时只有1种方法
    if (n <= 1) return 1;

    // 创建dp数组：dp[i]表示爬到第i阶的方法数
    const dp = new Array(n+1).fill(0);
    
    // 初始化已知条件（你的核心关注点）
    dp[0] = 1; // 没有台阶时有一种方法（不爬）
    dp[1] = 1; // 只有一阶时只能爬一步
    
    // 递推计算每一阶的方法数
    for (let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]; // 状态转移方程
    }
    
    return dp[n]; // 返回目标值
};
```

## 如何优化？

那这样的话，可以用一个数组来保存中间结果。不过这样的话空间复杂度是O(n)。有没有可能优化空间呢？因为每次只需要前两个状态，所以可以用两个变量来保存前两个值，这样空间复杂度可以降到O(1)。

比如，用prev和curr两个变量。初始时，prev = 1（即dp[0]），curr =1（dp[1]）。然后从i=2到n，每次计算next = prev + curr。然后更新prev为curr，curr为next。最后curr就是dp[n]的值。

举个例子，n=2的话，i=2的时候，next=1+1=2，所以curr变成2，返回。n=3的时候，i=2得到next=2，此时prev=1，curr=2；i=3的时候，next=1+2=3，curr=3。这样结果正确。

所以这样的迭代方式应该可以解决问题，并且空间复杂度是O(1)，时间则是O(n)。

那这样的话，代码的大体结构就是：

```js
function climbStairs(n) {

    if(n <=1) return 1; 
    let prev = 1, 
        curr =1;
    for(let i=2; i<=n; i++){ 

        let next = prev + curr;
        prev = curr;
        curr = next;

    }
    return curr;
}
```

## 思路整理

回顾下解题思路：

::: tip

- 问题分析：

   每次可以爬1或2个台阶，到达第n阶的方法数等于到达第 n - 1 阶和第 n - 2 阶方法数的总和，即斐波那契数列。

- 动态规划优化：

   使用两个变量保存前两步的结果，避免使用数组存储中间状态，将空间复杂度从O(n)优化到O(1)。

- 初始条件：

   当 n = 0 或 n = 1 时，方法数均为1。逐步迭代计算到第n阶的方法数。
:::
